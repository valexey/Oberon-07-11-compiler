MODULE Compiler;

IMPORT RTL, DECL, SCAN, UTILS, X86, SYSTEM;

CONST

  lxEOF = 0; lxINT = 1; lxREAL = 2; lxSTRING = 3; lxIDENT = 4; lxHEX = 5; lxCHX = 6; lxLONGREAL = 7;
  lxARRAY = 101; lxBEGIN = 102; lxBY = 103; lxCASE = 104; lxCONST = 105; lxDIV = 106;
  lxDO = 107; lxELSE = 108; lxELSIF = 109; lxEND = 110; lxFALSE = 111; lxFOR = 112;
  lxIF = 113; lxIMPORT = 114; lxIN = 115; lxIS = 116; lxMOD = 117; lxMODULE = 118;
  lxNIL = 119; lxOF = 120; lxOR = 121; lxPOINTER = 122; lxPROCEDURE = 123; lxRECORD = 124;
  lxREPEAT = 125; lxRETURN = 126; lxTHEN = 127; lxTO = 128; lxTRUE = 129; lxTYPE = 130;
  lxUNTIL = 131; lxVAR = 132; lxWHILE = 133;
  lxPlus = 301; lxMinus = 302; lxMult = 303; lxSlash = 304; lxNot = 305; lxAnd = 306;
  lxComma = 307; lxSemi = 308; lxStick = 309; lxLRound = 310; lxLSquare = 311;
  lxLCurly = 312; lxCaret = 313; lxEQ = 314; lxNE = 315; lxRRound = 316; lxRSquare = 317;
  lxRCurly = 318; lxDot = 319; lxDbl = 320; lxGT = 321; lxGE = 322; lxLT = 323;
  lxLE = 324; lxAssign = 325; lxColon = 326;

  TINTEGER = 1; TREAL = 2; TLONGREAL = 3; TCHAR = 4; TSET = 5; TBOOLEAN = 6; TVOID = 7;
  TNIL = 8; TCARD16 = 9; TSTRING = 10; TARRAY = 11; TRECORD = 12; TPOINTER = 13; TPROC = 14;

  eVAR = 1; eCONST = 2; eEXP = 3; ePROC = 4; eSTPROC = 5; eSYSPROC = 6;

  IDMOD = 1; IDCONST = 2; IDTYPE = 3; IDVAR = 4; IDPROC = 5; IDSTPROC = 6; IDGUARD = 7; IDPARAM = 8; IDSYSPROC = 9;

  stABS = 1; stODD = 2; stLEN = 3; stLSL = 4; stASR = 5; stROR = 6; stFLOOR = 7; stFLT = 8;
  stORD = 9; stCHR = 10; stLONG = 11; stSHORT = 12; stINC = 13; stDEC = 14; stINCL = 15;
  stEXCL = 16; stCOPY = 17; stNEW = 18; stASSERT = 19; stPACK = 20; stUNPK = 21; stDISPOSE = 22;

  sysADR = 101; sysSIZE = 102; sysBIT = 103; sysGET = 104; sysPUT = 105; sysCODE = 106;
  sysLOADLIB = 107; sysFREELIB = 108; sysGETPROC = 109; sysHALT = 110;

TYPE

  LABEL = POINTER TO rLABEL;

  rLABEL = RECORD (UTILS.rITEM)
    a, b: INTEGER
  END;

VAR

  pExpr, pFactor: PROCEDURE (VAR e: DECL.EXPRESSION);
  pOpSeq: PROCEDURE;
  Lex: SCAN.LEXSTR;
  sttypes: DECL.stTYPES;

PROCEDURE Load(e: DECL.EXPRESSION);
BEGIN
  IF e.eType = eVAR THEN
    X86.Load(e.T.tType)
  END
END Load;

PROCEDURE LenString(adr: LONGREAL): INTEGER;
VAR s: DECL.STRCONST;
BEGIN
  s := DECL.GetString(adr)
  RETURN s.Len
END LenString;

PROCEDURE Coord(VAR line, col: INTEGER);
BEGIN
  line := SCAN.line;
  col := SCAN.col
END Coord;

PROCEDURE Assert(cond: BOOLEAN; line, col, code: INTEGER);
BEGIN
  DECL.Assert(cond, line, col, code)
END Assert;

PROCEDURE Assert2(cond: BOOLEAN; code: INTEGER);
BEGIN
  DECL.Assert(cond, SCAN.line, SCAN.col, code)
END Assert2;

PROCEDURE Next;
BEGIN
  DECL.Next
END Next;

PROCEDURE Check(key: INTEGER);
BEGIN
  DECL.Check(key)
END Check;

PROCEDURE BaseOf(T0, T1: DECL.pTYPE): BOOLEAN;
BEGIN
  IF (T0.tType = T1.tType) & (T0.tType IN {TRECORD, TPOINTER}) THEN
    IF T0.tType = TPOINTER THEN
      T0 := T0.Base;
      T1 := T1.Base
    END;
    WHILE (T1 # NIL) & (T1 # T0) DO
      T1 := T1.Base
    END
  END
  RETURN T0 = T1
END BaseOf;

PROCEDURE Designator(VAR e: DECL.EXPRESSION);
VAR id: DECL.IDENT; name: SCAN.NODE; e1: DECL.EXPRESSION;
    line, col, i, n, bases: INTEGER;
    imp, break, flag, guard: BOOLEAN; f: DECL.FIELD;
    T, BaseT: DECL.pTYPE; s: DECL.STRCONST;
BEGIN
  Coord(line, col);
  Check(lxIDENT);
  name := SCAN.id;
  id := DECL.GetIdent(name);
  IF (id # NIL) & (id.iType = IDMOD) THEN
    Next;
    Check(lxDot);
    Next;
    Check(lxIDENT);
    Coord(line, col);
    name := SCAN.id;
    imp := id.Unit # DECL.unit;
    id := DECL.GetQIdent(id.Unit, name)
  END;
  Assert(id # NIL, line, col, 42);
  e.vparam := FALSE;
  e.deref := FALSE;
  Next;
  CASE id.iType OF
  |IDVAR:
    e.id := id;
    e.eType := eVAR;
    e.T := id.T;
    IF id.VarKind = 0 THEN
      e.Read := imp
    ELSE
      e.eType := eVAR;
      e.T := id.T;
      e.Read := (id.VarKind = DECL.param) & (id.T.tType IN {TRECORD, TARRAY});
      e.vparam := id.VarKind = DECL.paramvar
    END;
    bases := DECL.unit.Level - id.Level;
    IF id.Level = 3 THEN
      X86.GlobalAdr(id.Offset)
    ELSIF (id.VarKind = 0) OR (id.VarKind = DECL.param) & ~(id.T.tType IN {TARRAY, TRECORD}) THEN
      X86.LocalAdr(id.Offset, bases)
    ELSIF (id.VarKind = DECL.paramvar) OR (id.T.tType IN {TARRAY, TRECORD}) THEN
      IF DECL.Dim(e.T) > 0 THEN
        n := DECL.Dim(e.T);
        FOR i := n TO 1 BY -1 DO
          X86.LocalAdr(id.Offset + i * 4, bases);
          X86.Load(TINTEGER)
        END
      END;
      X86.LocalAdr(id.Offset, bases);
      X86.Load(TINTEGER)
    END
  |IDCONST:
    e.eType := eCONST;
    e.T := id.T;
    e.Value := id.Value;
    IF id.T.tType IN {TINTEGER, TSET, TBOOLEAN} THEN
      X86.PushConst(FLOOR(e.Value))
    ELSIF id.T.tType IN {TREAL, TLONGREAL} THEN
      X86.PushFlt(e.Value)
    ELSIF id.T.tType = TSTRING THEN
      s := DECL.GetString(e.Value);
      IF s.Len = 1 THEN
        X86.PushConst(ORD(s.Str[0]))
      ELSE
        X86.PushInt(s.Number)
      END
    END
  |IDPROC:
    e.eType := ePROC;
    e.id := id;
    e.T := sttypes[TVOID]
  |IDTYPE:
    Assert(FALSE, line, col, 101)
  |IDSTPROC:
    e.eType := eSTPROC;
    e.id := id;
    e.T := sttypes[TVOID]
  |IDSYSPROC:
    e.eType := eSYSPROC;
    e.id := id;
    e.T := sttypes[TVOID]
  END;
  break := FALSE;
  guard := FALSE;
  REPEAT
    flag := TRUE;
    CASE SCAN.tLex OF
    |lxDot:
      e.deref := FALSE;
      flag := FALSE;
      Assert2(e.T.tType IN {TPOINTER, TRECORD}, 105);
      IF e.T.tType = TPOINTER THEN
        e.T := e.T.Base;
        X86.Load(TINTEGER);
        IF ~guard THEN
          X86.CheckNIL
        END
      END;
      Next;
      Check(lxIDENT);
      Coord(line, col);
      name := SCAN.id;
      T := e.T;
      REPEAT
        f := DECL.GetField(T, name);
        T := T.Base
      UNTIL (f # NIL) OR (T = NIL);
      Assert(f # NIL, line, col, 99);
      IF f.Unit # DECL.unit THEN
        Assert(f.Export, line, col, 99)
      END;
      X86.Field(f.Offset);
      e.T := f.T;
      e.vparam := FALSE;
      guard := FALSE;
      Next
    |lxLSquare:
      flag := FALSE;
      REPEAT
        Assert2(e.T.tType = TARRAY, 102);
        Next;
        Coord(line, col);
        pExpr(e1);
        Assert(e1.T.tType = TINTEGER, line, col, 52);
        Load(e1);
        IF e.T.Len = 0 THEN
          BaseT := DECL.OpenBase(e.T);
          X86.PushConst(BaseT.Size);
          X86.OpenIdx(DECL.Dim(e.T))
        ELSE
          IF e1.eType = eCONST THEN
            Assert((FLOOR(e1.Value) >= 0) & (FLOOR(e1.Value) < e.T.Len), line, col, 159);
            X86.Idx(e.T.Base.Size)
          ELSE
            X86.FixIdx(e.T.Len, e.T.Base.Size)
          END
        END;
        e.T := e.T.Base
      UNTIL SCAN.tLex # lxComma;
      Check(lxRSquare);
      e.vparam := FALSE;
      guard := FALSE;
      Next
    |lxCaret:
      flag := FALSE;
      Assert2(e.T.tType = TPOINTER, 104);
      X86.Load(TINTEGER);
      IF ~guard THEN
        X86.CheckNIL
      END;
      e.T := e.T.Base;
      e.vparam := FALSE;
      e.deref := TRUE;
      guard := FALSE;
      Next
    |lxLRound:
      flag := FALSE;
      IF e.T.tType IN {TRECORD, TPOINTER} THEN
        IF e.T.tType = TRECORD THEN
          Assert2(e.vparam, 108)
        END;
        Next;
        Check(lxIDENT);
        Coord(line, col);
        T := DECL.IdType(line, col);
        Assert(T # NIL, line, col, 42);
        IF e.T.tType = TRECORD THEN
          Assert(T.tType = TRECORD, line, col, 106)
        ELSE
          Assert(T.tType = TPOINTER, line, col, 107)
        END;
        Assert(BaseOf(e.T, T), line, col, 108);
        e.T := T;
        Check(lxRRound);
        Next;
        IF e.T.tType = TPOINTER THEN
          X86.DupLoadCheck;
          guard := TRUE;
          T := T.Base
        ELSE
          X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
        END;
        X86.Guard(T.Number, FALSE)
      ELSE
        break := TRUE
      END
    END;
    IF flag THEN
      break := TRUE
    END
  UNTIL break
END Designator;

PROCEDURE Set(VAR e: DECL.EXPRESSION);
VAR a, b: DECL.EXPRESSION; line, col: INTEGER; s: SET; flag: BOOLEAN;
BEGIN
  Next;
  e.eType := eEXP;
  e.T := sttypes[TSET];
  e.Value := 0.0D0;
  e.vparam := FALSE;
  s := {};
  flag := TRUE;
  X86.PushConst(0);
  WHILE SCAN.tLex # lxRCurly DO
    Coord(line, col);
    pExpr(a);
    Assert(a.T.tType = TINTEGER, line, col, 52);
    IF a.eType = eCONST THEN
      Assert(ASR(FLOOR(a.Value), 5) = 0, line, col, 53)
    END;
    Load(a);
    b := a;
    IF SCAN.tLex = lxDbl THEN
      Next;
      Coord(line, col);
      pExpr(b);
      Assert(b.T.tType = TINTEGER, line, col, 52);
      IF b.eType = eCONST THEN
        Assert(ASR(FLOOR(b.Value), 5) = 0, line, col, 53);
        Assert(a.Value <= b.Value, line, col, 54)
      END;
      Load(b)
    ELSE
      X86.Dup
    END;
    X86.rset;
    X86.Set(lxPlus);
    flag := (a.eType = eCONST) & (b.eType = eCONST) & flag;
    IF flag THEN
      s := s + {FLOOR(a.Value) .. FLOOR(b.Value)}
    END;
    IF SCAN.tLex = lxComma THEN
      Next;
      Assert2(SCAN.tLex # lxRCurly, 36)
    ELSE
      Check(lxRCurly)
    END
  END;
  IF flag THEN
    e.Value := LONG(FLT(ORD(s)));
    e.eType := eCONST
  END;
  Next
END Set;

PROCEDURE IsString(a: DECL.EXPRESSION): BOOLEAN;
BEGIN
  RETURN (a.T.tType = TSTRING) OR (a.T.tType = TARRAY) & (a.T.Base.tType = TCHAR)
END IsString;

PROCEDURE StFunc(VAR e: DECL.EXPRESSION; func: INTEGER);
VAR line, col, line2, col2, a, p: INTEGER; e1, e2: DECL.EXPRESSION;
    T: DECL.pTYPE; str, str2: DECL.STRCONST; begcall: UTILS.ITEM;
BEGIN
  e.vparam := FALSE;
  e.eType := eEXP;
  Coord(line2, col2);
  Check(lxLRound);
  Next;
  Coord(line, col);
  CASE func OF
  |stABS:
    pExpr(e1);
    Assert(e1.T.tType IN {TINTEGER, TREAL, TLONGREAL}, line, col, 57);
    Load(e1);
    IF e1.eType = eCONST THEN
      e.Value := ABS(e1.Value);
      e.eType := eCONST;
      Assert(~((e1.T.tType = TINTEGER) & (e1.Value = LONG(FLT(SCAN.minINT)))), line, col, DECL.IOVER)
    END;
    IF e1.T.tType = TINTEGER THEN
      X86.StFunc(X86.stABS)
    ELSE
      X86.StFunc(X86.stFABS)
    END;
    e.T := e1.T
  |stODD:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    IF e1.eType = eCONST THEN
      e.Value := LONG(FLT(ORD(ODD(FLOOR(e1.Value)))));
      e.eType := eCONST
    END;
    X86.StFunc(X86.stODD);
    e.T := sttypes[TBOOLEAN]
  |stLEN:
    Designator(e1);
    Assert((e1.eType = eVAR) & (e1.T.tType = TARRAY), line, col, 102);
    IF e1.T.Len > 0 THEN
      X86.Len(-e1.T.Len)
    ELSE
      X86.Len(DECL.Dim(e1.T))
    END;
    e.T := sttypes[TINTEGER]
  |stLSL, stASR, stROR:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    Check(lxComma);
    Next;
    Coord(line, col);
    pExpr(e2);
    Assert(e2.T.tType = TINTEGER, line, col, 52);
    Load(e2);
    IF (e1.eType = eCONST) & (e2.eType = eCONST) THEN
      a := FLOOR(e1.Value);
      CASE func OF
      |stLSL: e.Value := LONG(FLT(LSL(a, FLOOR(e2.Value))))
      |stASR: e.Value := LONG(FLT(ASR(a, FLOOR(e2.Value))))
      |stROR: e.Value := LONG(FLT(ROR(a, FLOOR(e2.Value))))
      END;
      e.eType := eCONST
    END;
    CASE func OF
    |stLSL: X86.StFunc(X86.stLSL)
    |stASR: X86.StFunc(X86.stASR)
    |stROR: X86.StFunc(X86.stROR)
    END;
    e.T := sttypes[TINTEGER]
  |stFLOOR:
    pExpr(e1);
    Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 66);
    Load(e1);
    IF e1.eType = eCONST THEN
      Assert((e1.Value - 1.0D0 < LONG(FLT(SCAN.maxINT))) & (e1.Value >= LONG(FLT(SCAN.minINT))), line, col, 74);
      e.Value := LONG(FLT(FLOOR(e1.Value)));
      e.eType := eCONST
    END;
    X86.StFunc(X86.stFLOOR);
    e.T := sttypes[TINTEGER]
  |stFLT:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    IF e1.eType = eCONST THEN
      e.Value := e1.Value;
      e.eType := eCONST
    END;
    X86.StFunc(X86.stFLT);
    e.T := sttypes[TREAL]
  |stORD:
    pExpr(e1);
    Assert(e1.T.tType IN {TCHAR, TBOOLEAN, TSET, TSTRING}, line, col, 68);
    IF e1.T.tType = TSTRING THEN
      Assert(LenString(e1.Value) = 1, line, col, 94)
    END;
    Load(e1);
    IF e1.eType = eCONST THEN
      IF e1.T.tType = TSTRING THEN
        str := DECL.GetString(e1.Value);
        e.Value := LONG(FLT(ORD(str.Str[0])))
      ELSE
        e.Value := e1.Value
      END;
      e.eType := eCONST
    END;
    IF e1.T.tType = TBOOLEAN THEN
      X86.StFunc(X86.stORD)
    END;
    e.T := sttypes[TINTEGER]
  |stCHR:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    e.T := sttypes[TCHAR];
    IF e1.eType = eCONST THEN
      Assert(ASR(FLOOR(e1.Value), 8) = 0, line, col, 76);
      str2 := DECL.AddMono(CHR(FLOOR(e1.Value)));
      SYSTEM.GET(SYSTEM.ADR(str2), p);
      e.Value := LONG(FLT(p));
      e.T := sttypes[TSTRING];
      e.eType := eCONST
    END
  |stLONG:
    pExpr(e1);
    Assert(e1.T.tType = TREAL, line, col, 71);
    IF e1.eType = eCONST THEN
      e.Value := e1.Value;
      e.eType := eCONST
    END;
    Load(e1);
    e.T := sttypes[TLONGREAL]
  |stSHORT:
    pExpr(e1);
    Assert(e1.T.tType = TLONGREAL, line, col, 70);
    IF e1.eType = eCONST THEN
      Assert(ABS(e1.Value) <= LONG(SCAN.maxREAL), line, col, DECL.FOVER);
      Assert(ABS(e1.Value) >= LONG(SCAN.minREAL), line, col, DECL.UNDER);
      e.Value := e1.Value;
      e.eType := eCONST
    END;
    Load(e1);
    e.T := sttypes[TREAL]
  |sysADR:
    IF (SCAN.tLex = lxSTRING) OR (SCAN.tLex = lxCHX) THEN
      pFactor(e1)
    ELSIF SCAN.tLex = lxIDENT THEN
      Designator(e1)
    ELSE
      Assert(FALSE, line, col, 43)
    END;
    IF (e1.eType = eCONST) & (e1.T = sttypes[TSTRING]) THEN
      str := DECL.GetString(e1.Value);
      IF str.Len = 1 THEN
        X86.Drop;
        X86.PushInt(str.Number)
      END
    END;
    Assert((e1.eType = eVAR) OR (e1.eType = eCONST) & (e1.T = sttypes[TSTRING]), line, col, 43);
    e.T := sttypes[TINTEGER];
    IF DECL.Dim(e1.T) > 0 THEN
      X86.ADR(DECL.Dim(e1.T))
    END
  |sysBIT:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    Check(lxComma);
    Next;
    Coord(line, col);
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    X86.StFunc(X86.sysBIT);
    e.T := sttypes[TBOOLEAN]
  |sysSIZE:
    DECL.SetSizeFunc;
    Check(lxIDENT);
    T := DECL.IdType(line, col);
    Assert(T # NIL, line, col, 42);
    e.eType := eCONST;
    e.Value := LONG(FLT(T.Size));
    e.T := sttypes[TINTEGER];
    X86.PushConst(T.Size)
  |sysFREELIB:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    e.T := sttypes[TBOOLEAN];
    X86.StFunc(X86.sysFREELIB)
  |sysLOADLIB:
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    e.T := sttypes[TINTEGER];
    X86.StFunc(X86.sysLOADLIB)
  |sysGETPROC:
    begcall := X86.current;
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    Check(lxComma);
    Next;
    Coord(line, col);
    X86.PushCall(begcall);
    X86.Param;
    pExpr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    e.T := sttypes[TINTEGER];
    X86.EndCall;
    X86.StFunc(X86.sysGETPROC)
  |stINC, stDEC, stINCL, stEXCL, stCOPY,
   stNEW, stASSERT, stPACK, stUNPK, stDISPOSE,
   sysGET, sysPUT, sysHALT:
    Assert(FALSE, line2, col2, 73)
  END;
  Check(lxRRound);
  Next
END StFunc;

PROCEDURE ProcTypeComp(T1, T2: DECL.pTYPE): BOOLEAN;
VAR fp, ft: UTILS.ITEM; Res: BOOLEAN;

  PROCEDURE TypeComp(T1, T2: DECL.pTYPE): BOOLEAN;
  VAR Res: BOOLEAN;
  BEGIN
    IF (T1.tType = TARRAY) & (T2.tType = TARRAY) & (T1.Len = 0) & (T2.Len = 0) THEN
      Res := TypeComp(T1.Base, T2.Base)
    ELSE
      Res := ProcTypeComp(T1, T2)
    END
    RETURN Res
  END TypeComp;

BEGIN
  IF (T1.tType = TPROC) & (T2.tType = TPROC) THEN
    Res := (T1.Fields.Count = T2.Fields.Count) & ProcTypeComp(T1.Base, T2.Base);
    fp := T1.Fields.First;
    ft := T2.Fields.First;
    WHILE Res & (fp # NIL) DO
      Res := (fp(DECL.FIELD).ByRef = ft(DECL.FIELD).ByRef) & TypeComp(fp(DECL.FIELD).T, ft(DECL.FIELD).T);
      fp := fp.Next;
      ft := ft.Next
    END
  ELSE
    Res := T1 = T2
  END
  RETURN Res
END ProcTypeComp;

PROCEDURE ArrComp(Ta, Tf: DECL.pTYPE): BOOLEAN;
VAR Res: BOOLEAN;
BEGIN
  IF (Tf.tType = TARRAY) & (Tf.Len = 0) & (Ta.tType = TARRAY) THEN
    Res := ArrComp(Ta.Base, Tf.Base)
  ELSE
    Res := ProcTypeComp(Ta, Tf)
  END
  RETURN Res
END ArrComp;

PROCEDURE AssComp(e: DECL.EXPRESSION; T: DECL.pTYPE; param: BOOLEAN): BOOLEAN;
VAR Res: BOOLEAN;
BEGIN
  Res := FALSE;
  CASE T.tType OF
  |TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN, TCARD16:
    Res := e.T = T
  |TCHAR:
    IF e.T.tType = TSTRING THEN
      Res := LenString(e.Value) = 1
    ELSE
      Res := e.T.tType = TCHAR
    END
  |TARRAY:
    IF param THEN
      IF T.Len = 0 THEN
        IF (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) THEN
          Res := TRUE
        ELSE
          Res := ArrComp(e.T, T)
        END
      ELSE
        IF (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) THEN
          Res := LenString(e.Value) <= T.Len
        ELSE
          Res := e.T = T
        END
      END
    ELSE
      IF T.Len = 0 THEN
        Res := FALSE
      ELSIF (T.Base.tType = TCHAR) & (e.T.tType = TSTRING) THEN
        Res := LenString(e.Value) <= T.Len
      ELSE
        Res := e.T = T
      END
    END
  |TRECORD: Res := BaseOf(T, e.T)
  |TPOINTER: Res := BaseOf(T, e.T) OR (e.T.tType = TNIL)
  |TPROC: Res := (e.T.tType = TNIL) OR (e.eType = ePROC) & ProcTypeComp(e.id.T, T) OR
    (e.eType # ePROC) & ProcTypeComp(e.T, T)
  END
  RETURN Res
END AssComp;

PROCEDURE ParamComp(e: DECL.EXPRESSION; T: DECL.pTYPE; ByRef: BOOLEAN): BOOLEAN;
VAR Res: BOOLEAN;
BEGIN
  IF ByRef THEN
    IF e.eType = eVAR THEN
      CASE T.tType OF
      |TINTEGER, TREAL, TLONGREAL, TCHAR,
       TSET, TBOOLEAN, TPOINTER, TCARD16:
        Res := e.T = T
      |TARRAY:
        IF T.Len > 0 THEN
          Res := e.T = T
        ELSE
          Res := ArrComp(e.T, T)
        END
      |TRECORD:
        Res := BaseOf(T, e.T)
      |TPROC:
        Res := ProcTypeComp(e.T, T)
      END
    ELSE
      Res := FALSE
    END
  ELSE
    Res := AssComp(e, T, TRUE)
  END
  RETURN Res
END ParamComp;

PROCEDURE Call(param: UTILS.ITEM);
VAR line, col, i, n: INTEGER; e1: DECL.EXPRESSION; s: DECL.STRCONST; A: X86.TIDX; TA: DECL.pTYPE;
BEGIN
  WHILE param # NIL DO
    Coord(line, col);
    X86.Param;
    pExpr(e1);
    Assert(ParamComp(e1, param(DECL.FIELD).T, param(DECL.FIELD).ByRef), line, col, 114);
    Assert(~(param(DECL.FIELD).ByRef & e1.Read), line, col, 115);
    Assert(~((e1.eType = ePROC) & (e1.id.Level > 3)), line, col, 116);
    IF (e1.eType = eVAR) & ~param(DECL.FIELD).ByRef THEN
      X86.Load(e1.T.tType)
    END;
    IF param(DECL.FIELD).ByRef & (e1.T.tType = TRECORD) THEN
      IF e1.vparam THEN
        X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
        X86.Load(TINTEGER)
      ELSIF e1.deref THEN
        X86.DerefType(0)
      ELSE
        X86.PushConst(e1.T.Number)
      END
    END;
    IF ~param(DECL.FIELD).ByRef & (param(DECL.FIELD).T.tType = TREAL) THEN
      X86.Short
    END;
    IF (e1.T.tType = TSTRING) & (param(DECL.FIELD).T.tType = TARRAY) THEN
      s := DECL.GetString(e1.Value);
      IF s.Len = 1 THEN
        X86.Mono(s.Number)
      END;
      IF param(DECL.FIELD).T.Len = 0 THEN
        A[0] := s.Len + 1;
        X86.OpenArray(A, 1)
      END
    END;
    IF (e1.T.tType = TARRAY) & (DECL.Dim(param(DECL.FIELD).T) > DECL.Dim(e1.T)) THEN
      n := DECL.Dim(param(DECL.FIELD).T) - DECL.Dim(e1.T);
      TA := DECL.OpenBase(e1.T);
      FOR i := 0 TO n - 1 DO
        A[i] := TA.Len;
        TA := TA.Base
      END;
      IF DECL.Dim(e1.T) = 0 THEN
        X86.OpenArray(A, n)
      ELSE
        X86.ExtArray(A, n, DECL.Dim(e1.T))
      END
    END;
    param := param.Next;
    IF param # NIL THEN
      Check(lxComma);
      Next
    END
  END;
  Check(lxRRound);
  Next
END Call;

PROCEDURE Factor(VAR e: DECL.EXPRESSION);
VAR line, col, ccall, p: INTEGER; begcall: UTILS.ITEM; s, str2: DECL.STRCONST; flag: BOOLEAN;
BEGIN
  e.eType := eCONST;
  e.vparam := FALSE;
  flag := TRUE;
  CASE SCAN.tLex OF
  |lxIDENT:
    flag := FALSE;
    begcall := X86.current;
    Designator(e);
    IF e.eType = ePROC THEN
      IF SCAN.tLex = lxLRound THEN
        Assert2(e.id.T.Base.tType # TVOID, 73);
        Next;
        X86.PushCall(begcall);
        Call(e.id.T.Fields.First);
        X86.EndCall;
        e.eType := eEXP;
        e.T := e.id.T.Base;
        IF e.id.Level = 3 THEN
          ccall := 0
        ELSIF e.id.Level > DECL.curBlock.Level THEN
          ccall := 1
        ELSE
          ccall := 2
        END;
        X86.Call(e.id.Number, TRUE, e.T.tType IN {TREAL, TLONGREAL}, ccall, e.id.Level - 3, DECL.curBlock.Level - 3)
      ELSE
        X86.PushInt(e.id.Number)
      END
    ELSIF (e.eType = eVAR) & (e.T.tType = TPROC) & (SCAN.tLex = lxLRound) THEN
      Assert2(e.T.Base.tType # TVOID, 73);
      Next;
      X86.PushCall(begcall);
      Call(e.T.Fields.First);
      X86.EndCall;
      e.eType := eEXP;
      e.T := e.T.Base;
      X86.CallVar(TRUE, e.T.tType IN {TREAL, TLONGREAL})
    ELSIF e.eType IN {eSTPROC, eSYSPROC} THEN
      StFunc(e, e.id.StProc)
    END
  |lxNIL:
    flag := FALSE;
    e.T := sttypes[TNIL];
    e.Value := 0.0D0;
    X86.PushConst(0);
    Next
  |lxTRUE:
    flag := FALSE;
    e.T := sttypes[TBOOLEAN];
    e.Value := 1.0D0;
    X86.PushConst(1);
    Next
  |lxFALSE:
    flag := FALSE;
    e.T := sttypes[TBOOLEAN];
    e.Value := 0.0D0;
    X86.PushConst(0);
    Next
  |lxCHX, lxSTRING:
    flag := FALSE;
    IF SCAN.tLex = lxSTRING THEN
      SCAN.GetLexStr(Lex);
      str2 := DECL.AddString(Lex);
      SYSTEM.GET(SYSTEM.ADR(str2), p);
      e.Value := LONG(FLT(p));
      s := DECL.GetString(e.Value);
      IF s.Len = 1 THEN
        X86.PushConst(ORD(s.Str[0]))
      ELSE
        X86.PushInt(s.Number)
      END
    ELSE
      str2 := DECL.AddMono(SCAN.vCHX);
      SYSTEM.GET(SYSTEM.ADR(str2), p);
      e.Value := LONG(FLT(p));
      X86.PushConst(ORD(SCAN.vCHX))
    END;
    e.T := sttypes[TSTRING];
    Next
  |lxREAL:
    flag := FALSE;
    e.T := sttypes[TREAL];
    e.Value := SCAN.vFLT;
    X86.PushFlt(SCAN.vFLT);
    Next
  |lxLONGREAL:
    flag := FALSE;
    e.T := sttypes[TLONGREAL];
    e.Value := SCAN.vFLT;
    X86.PushFlt(SCAN.vFLT);
    Next
  |lxINT, lxHEX:
    flag := FALSE;
    e.T := sttypes[TINTEGER];
    e.Value := LONG(FLT(SCAN.vINT));
    X86.PushConst(SCAN.vINT);
    Next
  |lxLRound:
    flag := FALSE;
    Next;
    pExpr(e);
    Check(lxRRound);
    Next
  |lxNot:
    flag := FALSE;
    Next;
    Coord(line, col);
    Factor(e);
    Assert(e.T.tType = TBOOLEAN, line, col, 37);
    Load(e);
    IF e.eType = eCONST THEN
      e.Value := LONG(FLT(ORD(e.Value = 0.0D0)))
    ELSE
      e.eType := eEXP
    END;
    X86.Not;
    e.vparam := FALSE
  |lxLCurly:
    flag := FALSE;
    Set(e)
  END;
  Assert2(~flag, 36)
END Factor;

PROCEDURE IsChr(a: DECL.EXPRESSION): BOOLEAN;
BEGIN
  RETURN (a.T.tType = TSTRING) & (LenString(a.Value) = 1) OR (a.T.tType = TCHAR)
END IsChr;

PROCEDURE StrRel(a, b: DECL.EXPRESSION; Op: INTEGER);
BEGIN
  IF ~(IsChr(a) OR IsChr(b)) THEN
    X86.strcmp(Op, 0)
  ELSIF IsChr(a) & IsChr(b) THEN
    X86.CmpInt(Op)
  ELSIF IsChr(a) THEN
    X86.strcmp(Op, 1)
  ELSE
    X86.strcmp(Op, -1)
  END
END StrRel;

PROCEDURE Operation(VAR a, b: DECL.EXPRESSION; Op, line, col: INTEGER);
BEGIN
  CASE Op OF
  |lxPlus, lxMinus, lxMult, lxSlash:
    Assert((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}) & (a.T.tType = b.T.tType), line, col, 37);
    Assert(~((Op = lxSlash) & (a.T.tType = TINTEGER)), line, col, 37);
    CASE a.T.tType OF
    |TINTEGER: X86.Int(Op)
    |TSET: X86.Set(Op)
    |TREAL, TLONGREAL: X86.farith(Op)
    END
  |lxDIV, lxMOD:
    Assert((a.T.tType = TINTEGER) & (b.T.tType = TINTEGER), line, col, 37);
    X86.idivmod(Op = lxMOD)
  |lxAnd, lxOR:
    Assert((a.T.tType = TBOOLEAN) & (b.T.tType = TBOOLEAN), line, col, 37)
  |lxIN:
    Assert((a.T.tType = TINTEGER) & (b.T.tType = TSET), line, col, 37);
    X86.inset
  |lxLT, lxLE, lxGT, lxGE:
    Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL}) & (a.T.tType = b.T.tType)) OR
      (IsChr(a) OR IsString(a)) & (IsChr(b) OR IsString(b)) OR
      (a.T.tType = TSET) & (b.T.tType = TSET) & ((Op = lxLE) OR (Op = lxGE)), line, col, 37);
    IF a.T.tType IN {TREAL, TLONGREAL} THEN
      X86.fcmp(Op)
    ELSIF a.T.tType = TSET THEN
      X86.Inclusion(Op)
    ELSIF IsString(a) OR IsString(b) THEN
      StrRel(a, b, Op)
    ELSE
      X86.CmpInt(Op)
    END
  |lxEQ, lxNE:
    Assert(((a.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET, TBOOLEAN}) & (a.T.tType = b.T.tType)) OR
      (IsChr(a) OR IsString(a)) & (IsChr(b) OR IsString(b)) OR
      (a.T.tType IN {TPOINTER, TPROC, TNIL}) & (b.T.tType = TNIL) OR
      (b.T.tType IN {TPOINTER, TPROC, TNIL}) & (a.T.tType = TNIL) OR
      (a.T.tType = TPOINTER) & (b.T.tType = TPOINTER) & (BaseOf(a.T, b.T) OR BaseOf(b.T, a.T)) OR
      (a.T.tType = TPROC) & ProcTypeComp(b.T, a.T) OR (a.eType = ePROC) & ProcTypeComp(b.T, a.id.T) OR
      (b.eType = ePROC) & ProcTypeComp(a.T, b.id.T), line, col, 37);
    IF a.T.tType IN {TREAL, TLONGREAL} THEN
      X86.fcmp(Op)
    ELSIF IsString(a) OR IsString(b) THEN
      StrRel(a, b, Op)
    ELSE
      X86.CmpInt(Op)
    END
  END;
  IF (a.eType # eCONST) OR (b.eType # eCONST) THEN
    a.eType := eEXP;
    IF DECL.Relation(Op) THEN
      a.T := sttypes[TBOOLEAN]
    END
  ELSE
    DECL.Calc(a.Value, b.Value, a.T, b.T, Op, line, col, a.Value, a.T)
  END;
  a.vparam := FALSE
END Operation;

PROCEDURE Term(VAR e: DECL.EXPRESSION);
VAR a: DECL.EXPRESSION; Op, line, col, L: INTEGER;
BEGIN
  Factor(e);
  WHILE (SCAN.tLex = lxMult) OR (SCAN.tLex = lxSlash) OR
    (SCAN.tLex = lxDIV) OR (SCAN.tLex = lxMOD) OR
     (SCAN.tLex = lxAnd) DO
    Load(e);
    Coord(line, col);
    Op := SCAN.tLex;
    Next;
    IF Op = lxAnd THEN
      L := X86.NewLabel();
      X86.IfWhile(L, FALSE)
    END;
    Factor(a);
    Load(a);
    IF Op = lxAnd THEN
      X86.Label(L)
    END;
    Operation(e, a, Op, line, col)
  END
END Term;

PROCEDURE Simple(VAR e: DECL.EXPRESSION);
VAR a: DECL.EXPRESSION; Op, line, col, uOp, uline, ucol, L: INTEGER;
BEGIN
  uOp := 0;
  IF (SCAN.tLex = lxPlus) OR (SCAN.tLex = lxMinus) THEN
    Coord(uline, ucol);
    uOp := SCAN.tLex;
    Next
  END;
  Term(e);
  IF uOp # 0 THEN
    Assert(e.T.tType IN {TINTEGER, TREAL, TLONGREAL, TSET}, uline, ucol, 37);
    Load(e);
    IF uOp = lxMinus THEN
      CASE e.T.tType OF
      |TINTEGER: X86.NegInt
      |TSET: X86.NegSet
      |TREAL, TLONGREAL: X86.fneg
      END
    END;
    IF (uOp = lxMinus) & (e.eType = eCONST) THEN
      CASE e.T.tType OF
      |TINTEGER:
        Assert(e.Value # LONG(FLT(SCAN.minINT)), uline, ucol, DECL.IOVER)
      |TSET:
        e.Value := -LONG(FLT(ORD(-UTILS.FloatToSet(e.Value))))
      END;
      e.Value := -e.Value
    END;
    IF e.eType # eCONST THEN
      e.eType := eEXP
    END;
    e.vparam := FALSE
  END;
  WHILE (SCAN.tLex = lxPlus) OR (SCAN.tLex = lxMinus) OR
     (SCAN.tLex = lxOR) DO
    Load(e);
    Coord(line, col);
    Op := SCAN.tLex;
    Next;
    IF Op = lxOR THEN
      L := X86.NewLabel();
      X86.IfWhile(L, TRUE)
    END;
    Term(a);
    Load(a);
    IF Op = lxOR THEN
      X86.Label(L)
    END;
    Operation(e, a, Op, line, col)
  END
END Simple;

PROCEDURE Str(e: DECL.EXPRESSION);
VAR A: X86.TIDX;
BEGIN
  IF (e.T.tType = TARRAY) & (e.T.Base.tType = TCHAR) & (e.T.Len # 0) THEN
    A[0] := e.T.Len;
    X86.OpenArray(A, 1)
  ELSIF e.T.tType = TSTRING THEN
    A[0] := LenString(e.Value) + 1;
    IF A[0] # 2 THEN
      X86.OpenArray(A, 1)
    END
  END
END Str;

PROCEDURE Expr(VAR e: DECL.EXPRESSION);
VAR a: DECL.EXPRESSION; Op, line, col, line2, col2: INTEGER; T: DECL.pTYPE; beg: UTILS.ITEM; s: DECL.STRCONST;
BEGIN
  beg := X86.current;
  Simple(e);
  IF DECL.Relation(SCAN.tLex) THEN
    Coord(line, col);
    Op := SCAN.tLex;
    Next;
    IF Op = lxIS THEN
      Assert(e.T.tType IN {TRECORD, TPOINTER}, line, col, 37);
      IF e.T.tType = TRECORD THEN
        Assert(e.vparam, line, col, 37)
      END;
      Check(lxIDENT);
      Coord(line2, col2);
      T := DECL.IdType(line2, col2);
      Assert(T # NIL, line2, col2, 42);
      IF e.T.tType = TRECORD THEN
        Assert(T.tType = TRECORD, line2, col2, 106)
      ELSE
        Assert(T.tType = TPOINTER, line2, col2, 107)
      END;
      Assert(BaseOf(e.T, T), line, col, 37);
      IF e.T.tType = TRECORD THEN
        X86.Drop;
        X86.LocalAdr(e.id.Offset, DECL.unit.Level - e.id.Level)
      END;
      Load(e);
      IF e.T.tType = TPOINTER THEN
        T := T.Base;
        X86.CheckNIL
      END;
      X86.Guard(T.Number, TRUE);
      e.T := sttypes[TBOOLEAN];
      e.eType := eEXP;
      e.vparam := FALSE
    ELSE
      Load(e);
      Str(e);
      Simple(a);
      Load(a);
      Str(a);
      Operation(e, a, Op, line, col)
    END
  END;
  IF e.eType = eCONST THEN
    X86.Del(beg);
    IF ~X86.Const THEN
      CASE e.T.tType OF
      |TREAL, TLONGREAL:
        X86.PushFlt(e.Value)
      |TINTEGER, TSET, TBOOLEAN, TNIL:
        X86.PushConst(FLOOR(e.Value))
      |TSTRING:
        s := DECL.GetString(e.Value);
        IF s.Len = 1 THEN
          X86.PushConst(ORD(s.Str[0]))
        ELSE
          X86.PushInt(s.Number)
        END
      END
    END
  END
END Expr;

PROCEDURE IfWhileOper(wh: BOOLEAN);
VAR e: DECL.EXPRESSION; line, col, L, L3: INTEGER;
BEGIN
  L := X86.NewLabel();
  IF wh THEN
    X86.Label(L)
  END;
  REPEAT
    Next;
    Coord(line, col);
    Expr(e);
    Assert(e.T.tType = TBOOLEAN, line, col, 117);
    Load(e);
    IF wh THEN
      Check(lxDO)
    ELSE
      Check(lxTHEN)
    END;
    L3 := X86.NewLabel();
    X86.ifwh(L3);
    Next;
    pOpSeq;
    X86.jmp(X86.JMP, L);
    X86.Label(L3)
  UNTIL SCAN.tLex # lxELSIF;
  IF ~wh & (SCAN.tLex = lxELSE) THEN
    Next;
    pOpSeq
  END;
  Check(lxEND);
  IF ~wh THEN
    X86.Label(L)
  END;
  Next
END IfWhileOper;

PROCEDURE RepeatOper;
VAR e: DECL.EXPRESSION; line, col, L: INTEGER;
BEGIN
  Next;
  L := X86.NewLabel();
  X86.Label(L);
  pOpSeq;
  Check(lxUNTIL);
  Next;
  Coord(line, col);
  Expr(e);
  Assert(e.T.tType = TBOOLEAN, line, col, 117);
  Load(e);
  X86.ifwh(L)
END RepeatOper;

PROCEDURE ForOper;
VAR e: DECL.EXPRESSION; line, col, LBeg, LEnd: INTEGER; Value: LONGREAL;
    T: DECL.pTYPE; name: SCAN.NODE; id: DECL.IDENT;
BEGIN
  Next;
  Check(lxIDENT);
  name := SCAN.id;
  id := DECL.GetIdent(name);
  Assert2(id # NIL, 42);
  Assert2(id.iType = IDVAR, 126);
  Assert2(id.VarKind = 0, 127);
  Assert2(id.T.tType = TINTEGER, 128);
  Assert2(id.Level = DECL.unit.Level, 129);
  Next;
  Check(lxAssign);
  Next;
  Coord(line, col);
  IF id.Level = 3 THEN
    X86.GlobalAdr(id.Offset)
  ELSE
    X86.LocalAdr(id.Offset, 0)
  END;
  X86.Dup;
  Expr(e);
  Assert(e.T.tType = TINTEGER, line, col, 52);
  Load(e);
  X86.Save(TINTEGER);
  Check(lxTO);
  Next;
  Coord(line, col);
  Expr(e);
  Assert(e.T.tType = TINTEGER, line, col, 52);
  Load(e);
  Value := 1.0D0;
  IF SCAN.tLex = lxBY THEN
    Next;
    Coord(line, col);
    DECL.ConstExpr(Value, T);
    Assert(T.tType = TINTEGER, line, col, 52);
    Assert(Value # 0.0D0, line, col, 122)
  END;
  Check(lxDO);
  Next;
  X86.For(Value > 0.0D0, LBeg, LEnd);
  pOpSeq;
  X86.NextFor(FLOOR(Value), LBeg, LEnd);
  Check(lxEND);
  Next
END ForOper;

PROCEDURE LabelVal(VAR a: INTEGER; int: BOOLEAN);
VAR name: SCAN.NODE; id: DECL.IDENT; str: DECL.STRCONST; flag: BOOLEAN;
BEGIN
  flag := TRUE;
  CASE SCAN.tLex OF
  |lxIDENT:
    flag := FALSE;
    name := SCAN.id;
    id := DECL.GetIdent(name);
    Assert2(id # NIL, 42);
    Assert2(id.iType = IDCONST, 160);
    IF int THEN
      Assert2(id.T.tType = TINTEGER, 161);
      a := FLOOR(id.Value)
    ELSE
      Assert2(id.T.tType = TSTRING, 55);
      Assert2(LenString(id.Value) = 1, 94);
      str := DECL.GetString(id.Value);
      a := ORD(str.Str[0])
    END
  |lxINT, lxHEX:
    flag := FALSE;
    Assert2(int, 55);
    a := SCAN.vINT
  |lxCHX, lxSTRING:
    flag := FALSE;
    Assert2(~int, 161);
    IF SCAN.tLex = lxSTRING THEN
      Assert2(SCAN.count = 2, 94);
      SCAN.GetLexStr(Lex);
      a := ORD(Lex[0])
    ELSE
      a := ORD(SCAN.vCHX)
    END
  END;
  IF flag THEN
    Assert2(~int, 161);
    Assert2(int, 55)
  ELSE
    Next
  END
END LabelVal;

PROCEDURE CheckLabel(a, b: INTEGER; Labels: UTILS.LIST): BOOLEAN;
VAR cur: UTILS.ITEM;
BEGIN
  cur := Labels.First;
  WHILE (cur # NIL) & ((b < cur(LABEL).a) OR (a > cur(LABEL).b)) DO
    cur := cur.Next
  END
  RETURN cur = NIL
END CheckLabel;

PROCEDURE Label(int: BOOLEAN; Labels: UTILS.LIST; LBeg: INTEGER);
VAR a, b: INTEGER; label: LABEL; line, col: INTEGER;
BEGIN
  Coord(line, col);
  LabelVal(a, int);
  b := a;
  IF SCAN.tLex = lxDbl THEN
    Next;
    LabelVal(b, int)
  END;
  Assert(a <= b, line, col, 158);
  Assert(CheckLabel(a, b, Labels), line, col, 100);
  NEW(label);
  DECL.MemErr(label = NIL);
  label.a := a;
  label.b := b;
  Labels.Push(Labels, label);
  X86.CaseLabel(a, b, LBeg)
END Label;

PROCEDURE Variant(int: BOOLEAN; Labels: UTILS.LIST; EndCase: INTEGER);
VAR LBeg, LEnd: INTEGER;
BEGIN
  LBeg := X86.NewLabel();
  LEnd := X86.NewLabel();
  IF ~((SCAN.tLex = lxStick) OR (SCAN.tLex = lxEND)) THEN
    Label(int, Labels, LBeg);
    WHILE SCAN.tLex = lxComma DO
      Next;
      Label(int, Labels, LBeg)
    END;
    Check(lxColon);
    Next;
    X86.jmp(X86.JMP, LEnd);
    X86.Label(LBeg);
    pOpSeq;
    X86.jmp(X86.JMP, EndCase);
    X86.Label(LEnd)
  END
END Variant;

PROCEDURE CaseOper;
VAR e: DECL.EXPRESSION; int: BOOLEAN; line, col, EndCase: INTEGER; Labels: UTILS.LIST;
BEGIN
  Next;
  Coord(line, col);
  Expr(e);
  Assert(e.T.tType IN {TCHAR, TSTRING, TINTEGER}, line, col, 156);
  Assert(~((e.T.tType = TSTRING) & (LenString(e.Value) # 1)), line, col, 94);
  int := e.T.tType = TINTEGER;
  Check(lxOF);
  Load(e);
  X86.Drop;
  Labels := UTILS.CreateList();
  DECL.MemErr(Labels = NIL);
  Next;
  EndCase := X86.NewLabel();
  Variant(int, Labels, EndCase);
  WHILE SCAN.tLex = lxStick DO
    Next;
    Variant(int, Labels, EndCase)
  END;
  Check(lxEND);
  X86.Label(EndCase);
  Next;
  Labels.Clear(Labels)
END CaseOper;

PROCEDURE CheckCode(Code: ARRAY OF CHAR; Len, line, col: INTEGER);
VAR i: INTEGER;
BEGIN
  Assert(~ODD(Len), line, col, 34);
  FOR i := 0 TO Len - 1 DO
    Assert(SCAN.HexDigit(Code[i]), line, col, 34)
  END
END CheckCode;

PROCEDURE StProc(proc: INTEGER);
VAR line, col, line2, col2: INTEGER; e1, e2: DECL.EXPRESSION; Value: LONGREAL;
    T: DECL.pTYPE; str: DECL.STRCONST; begcall: UTILS.ITEM;
BEGIN
  Coord(line2, col2);
  Check(lxLRound);
  Next;
  Coord(line, col);
  CASE proc OF
  |stINC, stDEC:
    Designator(e1);
    Assert(e1.eType = eVAR, line, col, 63);
    Assert(~e1.Read, line, col, 115);
    Assert(e1.T.tType = TINTEGER, line, col, 128);
    IF SCAN.tLex = lxComma THEN
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      Assert(Value # 0.0D0, line, col, 122);
      IF Value < 0.0D0 THEN
        IF proc = stINC THEN
          proc := stDEC
        ELSE
          proc := stINC
        END;
        Value := -Value
      END;
      IF Value # 1.0D0 THEN
        X86.PushConst(FLOOR(Value));
        IF proc = stDEC THEN
          X86.StProc(X86.stDEC, 0)
        ELSE
          X86.StProc(X86.stINC, 0)
        END
      ELSE
        IF proc = stDEC THEN
          X86.StProc(X86.stDEC1, 0)
        ELSE
          X86.StProc(X86.stINC1, 0)
        END
      END
    ELSE
      IF proc = stDEC THEN
        X86.StProc(X86.stDEC1, 0)
      ELSE
        X86.StProc(X86.stINC1, 0)
      END
    END
  |stINCL, stEXCL:
    Designator(e1);
    Assert(e1.eType = eVAR, line, col, 63);
    Assert(~e1.Read, line, col, 115);
    Assert(e1.T.tType = TSET, line, col, 138);
    Check(lxComma);
    Next;
    Coord(line, col);
    DECL.ConstExpr(Value, T);
    Assert(T.tType = TINTEGER, line, col, 52);
    Assert(ASR(FLOOR(Value), 5) = 0, line, col, 53);
    IF proc = stINCL THEN
      X86.PushSet({FLOOR(Value)});
      X86.StProc(X86.stINCL, 0)
    ELSE
      X86.PushSet(-{FLOOR(Value)});
      X86.StProc(X86.stEXCL, 0)
    END
  |stCOPY:
    Expr(e1);
    Assert(IsString(e1), line, col, 141);
    Check(lxComma);
    IF e1.T.tType = TSTRING THEN
      str := DECL.GetString(e1.Value);
      IF str.Len = 1 THEN
        X86.Mono(str.Number);
        X86.StrMono
      END
    END;
    Str(e1);
    Next;
    Coord(line, col);
    Designator(e2);
    Assert(e2.eType = eVAR, line, col, 63);
    Assert(IsString(e2), line, col, 143);
    Assert(~e2.Read, line, col, 115);
    Str(e2);
    X86.StProc(X86.stCOPY, 0)
  |stNEW, stDISPOSE:
    Designator(e1);
    Assert(e1.eType = eVAR, line, col, 63);
    Assert(~e1.Read, line, col, 115);
    Assert(e1.T.tType = TPOINTER, line, col, 145);
    IF proc = stNEW THEN
      X86.PushConst(e1.T.Base.Number);
      X86.PushConst(e1.T.Base.Size);
      X86.newrec
    ELSE
      X86.disprec
    END
  |stASSERT:
    Expr(e1);
    Assert(e1.T.tType = TBOOLEAN, line, col, 117);
    Load(e1);
    IF SCAN.tLex = lxComma THEN
      Next;
      Coord(line, col);
      DECL.ConstExpr(Value, T);
      Assert(T.tType = TINTEGER, line, col, 52);
      X86.StProc(X86.stASSERT, FLOOR(Value))
    ELSE
      X86.StProc(X86.stASSERT1, 0)
    END
  |stPACK, stUNPK:
    Designator(e1);
    Assert(e1.eType = eVAR, line, col, 63);
    Assert(e1.T.tType IN {TREAL, TLONGREAL}, line, col, 149);
    Assert(~e1.Read, line, col, 115);
    Check(lxComma);
    Next;
    Coord(line, col);
    IF proc = stUNPK THEN
      Designator(e2);
      Assert(e2.eType = eVAR, line, col, 63);
      Assert(e2.T.tType = TINTEGER, line, col, 128);
      Assert(~e2.Read, line, col, 115);
      IF e1.T.tType = TLONGREAL THEN
        X86.StProc(X86.stUNPK, 0)
      ELSE
        X86.StProc(X86.stUNPK1, 0)
      END
    ELSE
      Expr(e2);
      Assert(e2.T.tType = TINTEGER, line, col, 52);
      Load(e2);
      IF e1.T.tType = TLONGREAL THEN
        X86.StProc(X86.stPACK, 0)
      ELSE
        X86.StProc(X86.stPACK1, 0)
      END
    END
  |sysBIT:
    Expr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    Check(lxComma);
    Next;
    Coord(line, col);
    Expr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1)
  |sysPUT, sysGET:
    begcall := X86.current;
    Expr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    Check(lxComma);
    Next;
    Coord(line, col);
    IF proc = sysGET THEN
      X86.PushCall(begcall);
      X86.Param;
      Designator(e2);
      Assert(e2.eType = eVAR, line, col, 63);
      Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16}, line, col, 154);
      Assert(~e2.Read, line, col, 115);
      X86.EndCall;
      X86.Load(e2.T.tType);
      X86.Save(e2.T.tType)
    ELSE
      Expr(e2);
      Assert(e2.T.tType IN {TINTEGER, TREAL, TLONGREAL, TCHAR, TSET, TBOOLEAN, TCARD16, TSTRING}, line, col, 153);
      IF e2.T.tType = TSTRING THEN
        Assert(LenString(e2.Value) = 1, line, col, 94)
      END;
      Load(e2);
      X86.Save(e2.T.tType)
    END
  |sysCODE:
    Expr(e1);
    Assert(e1.T.tType = TSTRING, line, col, 150);
    str := DECL.GetString(e1.Value);
    CheckCode(str.Str, str.Len, line, col);
    X86.Asm(str.Str)
  |sysHALT:
    Expr(e1);
    Assert(e1.T.tType = TINTEGER, line, col, 52);
    Load(e1);
    X86.StProc(X86.sysHALT, 0)
  |stABS, stODD, stLEN, stASR, stROR, stLSL, stFLOOR,
   stFLT, stORD, stCHR, stLONG, stSHORT, sysADR, sysSIZE,
   sysGETPROC, sysFREELIB, sysLOADLIB:
     Assert(FALSE, line2, col2, 132)
  END;
  Check(lxRRound);
  IF proc = sysBIT THEN
    Next;
    Check(lxAssign);
    Next;
    Coord(line, col);
    Expr(e1);
    Assert(e1.T.tType = TBOOLEAN, line, col, 117);
    Load(e1);
    X86.StProc(X86.sysBIT, 0)
  ELSE
    Next
  END
END StProc;

PROCEDURE IdentOper;
VAR e1, e2: DECL.EXPRESSION; line, col, ccall: INTEGER; begcall: UTILS.ITEM; s: DECL.STRCONST;
BEGIN
  Coord(line, col);
  begcall := X86.current;
  Designator(e1);
  Assert(e1.eType # eCONST, line, col, 130);
  IF (e1.eType = eVAR) & (e1.T.tType # TPROC) THEN
    Check(lxAssign);
    Assert(~e1.Read, line, col, 115);
    Next;
    Coord(line, col);
    Expr(e2);
    Assert(AssComp(e2, e1.T, FALSE), line, col, 131);
    Load(e2);
    IF e1.T.tType = TRECORD THEN
      X86.PushConst(e1.T.Size);
      X86.PushConst(e1.T.Number);
      IF e1.vparam THEN
        X86.LocalAdr(e1.id.Offset - 4, DECL.unit.Level - e1.id.Level);
        X86.Load(TINTEGER)
      ELSIF e1.deref THEN
        X86.DerefType(12)
      ELSE
        X86.PushConst(e1.T.Number)
      END
    ELSIF e2.T.tType = TARRAY THEN
      X86.PushConst(e2.T.Size)
    ELSIF (e2.T.tType = TSTRING) & (e1.T.tType = TARRAY) THEN
      s := DECL.GetString(e2.Value);
      IF s.Len = 1 THEN
        X86.Mono(s.Number)
      END;
      X86.PushConst(UTILS.min(s.Len + 1, e1.T.Len))
    END;
    X86.Save(e1.T.tType)
  ELSIF e1.eType = ePROC THEN
    Assert(e1.id.T.Base.tType = TVOID, line, col, 132);
    IF e1.id.ParamCount > 0 THEN
      Check(lxLRound);
      Next;
      X86.PushCall(begcall);
      Call(e1.id.T.Fields.First);
      X86.EndCall
    ELSIF SCAN.tLex = lxLRound THEN
      Next;
      Check(lxRRound);
      Next
    END;
    IF e1.id.Level = 3 THEN
      ccall := 0
    ELSIF e1.id.Level > DECL.curBlock.Level THEN
      ccall := 1
    ELSE
      ccall := 2
    END;
    X86.Call(e1.id.Number, FALSE, FALSE, ccall, e1.id.Level - 3, DECL.curBlock.Level - 3)
  ELSIF e1.eType IN {eSTPROC, eSYSPROC} THEN
    StProc(e1.id.StProc)
  ELSIF (e1.eType = eVAR) & (e1.T.tType = TPROC) THEN
    IF SCAN.tLex = lxLRound THEN
      Next;
      Assert(e1.T.Base.tType = TVOID, line, col, 132);
      X86.PushCall(begcall);
      Call(e1.T.Fields.First);
      X86.EndCall;
      X86.CallVar(FALSE, FALSE)
    ELSIF SCAN.tLex = lxAssign THEN
      Assert(~e1.Read, line, col, 115);
      Next;
      Coord(line, col);
      Expr(e2);
      Assert(AssComp(e2, e1.T, FALSE), line, col, 131);
      Assert(~((e2.eType = ePROC) & (e2.id.Level > 3)), line, col, 116);
      IF e2.eType = eVAR THEN
        X86.Load(TPROC)
      END;
      X86.Save(TPROC)
    ELSE
      Assert2(e1.T.Fields.Count = 0, 155);
      Assert(e1.T.Base.tType = TVOID, line, col, 132);
      X86.CallVar(FALSE, FALSE)
    END
  END
END IdentOper;

PROCEDURE Operator;
BEGIN
  UTILS.UnitLine(DECL.UnitNumber, SCAN.line);
  CASE SCAN.tLex OF
  |lxIDENT: IdentOper
  |lxIF, lxWHILE: IfWhileOper(SCAN.tLex = lxWHILE)
  |lxREPEAT: RepeatOper
  |lxFOR: ForOper
  |lxCASE: CaseOper
  END
END Operator;

PROCEDURE OpSeq;
BEGIN
  Operator;
  WHILE SCAN.tLex = lxSemi DO
    Next;
    Operator
  END
END OpSeq;

PROCEDURE Start;
VAR SelfName, SelfPath, CName, CExt, FName, Path, StdPath, Name, Ext, temp, system, stk: UTILS.FILENAME;
    dll: BOOLEAN; i, conguidll, stksize: INTEGER;
BEGIN
  IF UTILS.ParamCount < 3 THEN
    UTILS.OutString("недостаточно параметров");
    UTILS.Ln;
    SYSTEM.HALT(1)
  END;
  UTILS.ParamStr(SelfName, 0);
  UTILS.ParamStr(FName, 1);
  UTILS.ParamStr(system, 2);
  UTILS.ParamStr(stk, 3);
  stksize := 0;
  i := 0;
  WHILE SCAN.Digit(stk[i]) DO
    INC(i)
  END;
  IF stk[i] <= 20X THEN
    stk[i] := 0X;
    stksize := SCAN.StrToInt(stk)
  END;
  IF stksize = 0 THEN
    stksize := 1
  END;
  pExpr := Expr;
  pFactor := Factor;
  pOpSeq := OpSeq;
  UTILS.Split(FName, Path, Name, Ext);
  UTILS.Split(SelfName, SelfPath, CName, CExt);
  UTILS.concat(SelfPath, "std\", SelfPath);
  temp := Name;
  IF UTILS.streq(system, "con") THEN
    conguidll := 3;
    UTILS.concat(temp, ".exe", temp)
  ELSIF UTILS.streq(system, "gui") THEN
    conguidll := 2;
    UTILS.concat(temp, ".exe", temp)
  ELSIF UTILS.streq(system, "dll") THEN
    conguidll := 1;
    UTILS.concat(temp, ".dll", temp)
  ELSE
    UTILS.OutString("недопустимый параметр");
    UTILS.Ln;
    SYSTEM.HALT(1)
  END;
  UTILS.OutString("компиляция...");
  UTILS.Ln;
  X86.Init(DECL.MemErr, conguidll);
  X86.Prolog(temp);
  DECL.Program(SelfPath, Path, Name, OpSeq, Expr, AssComp, sttypes);
  DECL.Compile;
  temp := Path;
  UTILS.concat(temp, Name, temp);
  IF conguidll # 1 THEN
    UTILS.concat(temp, ".exe", temp)
  ELSE
    UTILS.concat(temp, ".dll", temp)
  END;
  X86.Epilog(DECL.ProgSize, temp, stksize * 100000H, conguidll = 3);
END Start;

BEGIN
  Start
END Compiler.
